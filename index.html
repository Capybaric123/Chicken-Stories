<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser-arcade-physics.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

<script>
class Player {
    constructor(scene) {
        this.scene = scene;
        this.sprite = scene.add.circle(400, 300, 15, 0x00ff00);
        this.sprite.setOrigin(0.5, 0.5);
        scene.physics.world.enable(this.sprite);
        this.sprite.body.setCollideWorldBounds(true);
        this.speed = 200;
        this.health = 100;

        // WASD controls
        this.cursors = {
            left: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
            right: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
            up: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),
        };
        this.bullets = scene.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 10
        });

        scene.input.on('pointermove', pointer => {
            const angle = Phaser.Math.Angle.Between(this.sprite.x, this.sprite.y, pointer.x, pointer.y);
            this.sprite.rotation = angle;
        });

        scene.input.on('pointerdown', () => this.shoot());
    }

    update() {
        const angle = this.sprite.rotation;
        
        if (this.cursors.left.isDown) {
            this.sprite.body.setVelocity(Math.cos(angle - Math.PI / 2) * this.speed, Math.sin(angle - Math.PI / 2) * this.speed);
        } else if (this.cursors.right.isDown) {
            this.sprite.body.setVelocity(Math.cos(angle + Math.PI / 2) * this.speed, Math.sin(angle + Math.PI / 2) * this.speed);
        } else {
            this.sprite.body.setVelocity(0);
        }
        
        if (this.cursors.up.isDown) {
            this.scene.physics.velocityFromRotation(angle, this.speed, this.sprite.body.velocity);
        }
    }

    shoot() {
        if (this.bullets.getLength() < this.bullets.maxSize) {
            const bullet = this.bullets.get(this.sprite.x, this.sprite.y);
            if (bullet) {
                bullet.setActive(true);
                bullet.setVisible(true);
                bullet.setCircle(5, 0, 0);
                bullet.setOrigin(0.5, 0.5);
                bullet.setRotation(this.sprite.rotation);
                this.scene.physics.velocityFromRotation(this.sprite.rotation, 400, bullet.body.velocity);
                bullet.setCollideWorldBounds(true);
                bullet.setLifeSpan(2000); // Auto destroy after 2 seconds
            }
        }
    }
}

class Enemy {
    constructor(scene, x, y, type) {
        this.scene = scene;
        this.sprite = scene.add.polygon(x, y, this.getShape(type), 0xffffff);
        this.sprite.setOrigin(0.5, 0.5);
        scene.physics.world.enable(this.sprite);
        this.sprite.body.setVelocity(Phaser.Math.Between(-50, 50), Phaser.Math.Between(-50, 50));
        this.sprite.body.setCollideWorldBounds(true);
        this.sprite.body.setBounce(1);
        this.health = 50; // Each enemy has its own health
    }

    getShape(type) {
        switch (type) {
            case 'square':
                return [0, 0, 20, 0, 20, 20, 0, 20];
            case 'triangle':
                return [0, -15, 15, 15, -15, 15];
            case 'hexagon':
                return [0, -15, 13, -8, 13, 8, 0, 15, -13, 8, -13, -8];
            default:
                return [];
        }
    }

    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.sprite.destroy();
            return true; // Enemy destroyed
        }
        return false; // Enemy still alive
    }
}

class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
        this.score = 0;
    }

    preload() {
        this.load.image('bullet', 'assets/sprites/bullet.png'); // Placeholder for bullet sprite
        this.load.image('sky', 'assets/skies/space3.png');
    }

    create() {
        this.add.image(400, 300, 'sky');
        this.cameras.main.setBounds(0, 0, 1600, 1200); // Adjust camera bounds
        this.player = new Player(this);
        
        this.enemies = this.physics.add.group();
        this.spawnEnemies(5);

        this.physics.add.collider(this.player.bullets, this.enemies, this.bulletHitEnemy, null, this);
        this.physics.add.collider(this.player.sprite, this.enemies, this.hitEnemy, null, this);
        
        // Camera follows player
        this.cameras.main.startFollow(this.player.sprite);
    }

    update() {
        this.player.update();
    }

    spawnEnemies(count) {
        for (let i = 0; i < count; i++) {
            const type = Phaser.Utils.Array.GetRandom(['square', 'triangle', 'hexagon']);
            const x = Phaser.Math.Between(100, 1500);
            const y = Phaser.Math.Between(100, 1100);
            this.enemies.add(new Enemy(this, x, y, type).sprite);
        }
    }

    bulletHitEnemy(bullet, enemy) {
        bullet.setActive(false);
        bullet.setVisible(false);
        
        if (enemy.takeDamage(20)) { // Each bullet does 20 damage
            this.score += 10; // Increase score for destroying enemy
            console.log('Score:', this.score);
        }
    }

    hitEnemy(player, enemy) {
        // Handle player collision with enemy
        player.health -= 10; // Reduce player health
        console.log('Player Health:', player.health);
        
        if (player.health <= 0) {
            console.log('Game Over');
            this.scene.pause(); // Stop the game
        }
    }
}

const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    scene: GameScene,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 }
        }
    }
};

const game = new Phaser.Game(config);

// Resize the canvas to fit the window
window.addEventListener('resize', () => {
    game.resize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
